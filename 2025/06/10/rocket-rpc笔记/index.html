<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wjdmyby98k.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="以rocket为例，解析rpc调用过程。">
<meta property="og:type" content="article">
<meta property="og:title" content="rocket-rpc笔记">
<meta property="og:url" content="https://wjdmyby98k.github.io/2025/06/10/rocket-rpc%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="就是要摸鱼">
<meta property="og:description" content="以rocket为例，解析rpc调用过程。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-10T14:52:28.000Z">
<meta property="article:modified_time" content="2025-06-10T14:57:12.179Z">
<meta property="article:author" content="zhangyitao">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="rpc">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://wjdmyby98k.github.io/2025/06/10/rocket-rpc%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>rocket-rpc笔记 | 就是要摸鱼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">就是要摸鱼</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://wjdmyby98k.github.io/2025/06/10/rocket-rpc%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhangyitao">
      <meta itemprop="description" content="一切过往，皆为序曲">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="就是要摸鱼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          rocket-rpc笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-06-10 22:52:28 / 修改时间：22:57:12" itemprop="dateCreated datePublished" datetime="2025-06-10T22:52:28+08:00">2025-06-10</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/rpc/" itemprop="url" rel="index"><span itemprop="name">rpc</span></a>
                </span>
            </span>

          
            <div class="post-description">以rocket为例，解析rpc调用过程。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="RPC">RPC</h3>
<p><a target="_blank" rel="noopener" href="https://izualzhy.cn/demo-protobuf-rpc#2-server--client">如何基于protobuf实现一个极简版的RPC - Ying</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Gooddbird/rocket?tab=readme-ov-file">GitHub - Gooddbird/rocket: c++ rpc framework, simplified version of tinyrpc。</a></p>
<p>前者比较好入门RPC框架，需要用到proto工具，后者是另一个rpc的开源实现，他们都不同于grpc。这涉及到通用服务和grpc服务的问题。前者代码比较老，版本问题太多，放弃，主要学习一下调用逻辑，后者可以跑通。</p>
<p>rocket的坑：按照issue配置好xml的环境，ld path加上/usr/local/lib就行，还需要protoc --cpp_out=. order.proto自己生成对应的cc和h文件。</p>
<p>rocket的Makefile解释：比较清晰易懂</p>
<h3 id="通用服务和grpc服务？">通用服务和grpc服务？</h3>
<p>grpc官方的方式是grpc服务，如果我们想自定义rpc实现，需要在proto中修改<code>option cc_generic_services = true;</code>该字段与grpc插件互斥。这样生成的pb文件就只包含通用服务，不过该字段现在已经被建议废弃使用。同时，我们还需要自己实现数据发送接收，比如tcp、http等。grpc就是全部帮你封装好了，内部是http。数据编码解码全部采用protobuf，同时grpc自动帮你处理了service、method的对应关系。自己实现rpc就需要自己再写一遍。这里只记录学习过程。具体参考<a target="_blank" rel="noopener" href="https://izualzhy.cn/demo-protobuf-rpc#2-server--client">如何基于protobuf实现一个极简版的RPC - Ying</a></p>
<h4 id="关于一些版本问题">关于一些版本问题</h4>
<p>编译器默认的include目录可以通过<code>echo | g++ -v -x c++ -E -</code>查看</p>
<p>遇到的版本问题：protoc编译版本和protobuf库版本不匹配，系统中有多个protobuf.pc文件，首先查看一下pkg-config的搜索路径</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">echo $(pkg-config --variable pc_path pkg-config) | tr &#x27;:&#x27; &#x27;\n&#x27;</span><br><span class="line"></span><br><span class="line">/usr/local/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">/usr/local/lib/pkgconfig</span><br><span class="line">/usr/local/share/pkgconfig</span><br><span class="line">/usr/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line">/usr/lib/pkgconfig</span><br><span class="line">/usr/share/pkgconfig</span><br></pre></td></tr></table></figure>
<p>然后一个个找，查看 protobuf.pc里面的版本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg-config --modversion protobuf</span><br></pre></td></tr></table></figure>
<p>因为按照grpc官方的安装方式，grpc还有相应的库依赖全部装在.local目录下，所以得添加到pkg-config的搜索目录下</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PKG_CONFIG_PATH=/home/zyt/.local/lib/pkgconfig:$PKG_CONFIG_PATH&#x27; &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">export PKG_CONFIG_PATH=&quot;$PKG_CONFIG_PAT:/home/zyt/.local/lib/pkgconfig&quot;</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>
<p><font color =red>不同项目的proto版本都不同，api也不一样，所以别纠结版本的问题了</font></p>
<p>想查看cmake的include路径，可以通过</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">get_directory_property</span>(dirs <span class="keyword">INCLUDE_DIRECTORIES</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;After adding generated directory: $&#123;dirs&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="grpc官方例子">grpc官方例子</h4>
<p>CMakeLists.txt如下</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(HelloWorld C CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(../cmake/common.cmake)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Proto file</span></span><br><span class="line"><span class="keyword">get_filename_component</span>(hw_proto <span class="string">&quot;../../protos/helloworld.proto&quot;</span> ABSOLUTE)</span><br><span class="line"><span class="keyword">get_filename_component</span>(hw_proto_path <span class="string">&quot;$&#123;hw_proto&#125;&quot;</span> PATH)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated sources</span></span><br><span class="line"><span class="keyword">set</span>(hw_proto_srcs <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/helloworld.pb.cc&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(hw_proto_hdrs <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/helloworld.pb.h&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(hw_grpc_srcs <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/helloworld.grpc.pb.cc&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(hw_grpc_hdrs <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/helloworld.grpc.pb.h&quot;</span>)</span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">      OUTPUT <span class="string">&quot;$&#123;hw_proto_srcs&#125;&quot;</span> <span class="string">&quot;$&#123;hw_proto_hdrs&#125;&quot;</span> <span class="string">&quot;$&#123;hw_grpc_srcs&#125;&quot;</span> <span class="string">&quot;$&#123;hw_grpc_hdrs&#125;&quot;</span></span><br><span class="line">      <span class="keyword">COMMAND</span> <span class="variable">$&#123;_PROTOBUF_PROTOC&#125;</span></span><br><span class="line">      ARGS --grpc_out <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        --cpp_out <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span></span><br><span class="line">        -I <span class="string">&quot;$&#123;hw_proto_path&#125;&quot;</span></span><br><span class="line">        --plugin=protoc-gen-grpc=<span class="string">&quot;$&#123;_GRPC_CPP_PLUGIN_EXECUTABLE&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot;$&#123;hw_proto&#125;&quot;</span></span><br><span class="line">      DEPENDS <span class="string">&quot;$&#123;hw_proto&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include generated *.pb.h files</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;CMAKE_CURRENT_BINARY_DIR = $&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="comment"># hw_grpc_proto</span></span><br><span class="line"><span class="keyword">add_library</span>(hw_grpc_proto</span><br><span class="line">  <span class="variable">$&#123;hw_grpc_srcs&#125;</span></span><br><span class="line">  <span class="variable">$&#123;hw_grpc_hdrs&#125;</span></span><br><span class="line">  <span class="variable">$&#123;hw_proto_srcs&#125;</span></span><br><span class="line">  <span class="variable">$&#123;hw_proto_hdrs&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(hw_grpc_proto</span><br><span class="line">  absl::check</span><br><span class="line">  <span class="variable">$&#123;_REFLECTION&#125;</span></span><br><span class="line">  <span class="variable">$&#123;_GRPC_GRPCPP&#125;</span></span><br><span class="line">  <span class="variable">$&#123;_PROTOBUF_LIBPROTOBUF&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Targets greeter_[async_](client|server)</span></span><br><span class="line"><span class="keyword">foreach</span>(_target</span><br><span class="line">  greeter_client greeter_server</span><br><span class="line">  greeter_callback_client greeter_callback_server</span><br><span class="line">  greeter_async_client greeter_async_client2 greeter_async_server)</span><br><span class="line">  <span class="keyword">add_executable</span>(<span class="variable">$&#123;_target&#125;</span> <span class="string">&quot;$&#123;_target&#125;.cc&quot;</span>)</span><br><span class="line">  <span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;_target&#125;</span></span><br><span class="line">    hw_grpc_proto</span><br><span class="line">    absl::check</span><br><span class="line">    absl::flags</span><br><span class="line">    absl::flags_parse</span><br><span class="line">    absl::log</span><br><span class="line">    absl::log_initialize</span><br><span class="line">    <span class="variable">$&#123;_REFLECTION&#125;</span></span><br><span class="line">    <span class="variable">$&#123;_GRPC_GRPCPP&#125;</span></span><br><span class="line">    <span class="variable">$&#123;_PROTOBUF_LIBPROTOBUF&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>CMAKE_CURRENT_BINARY_DIR</code>在这里实际上就是cmake/build目录，也就是你执行cmake命令的目录，因此我们<code>include_directories(&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;&quot;)</code>便会自动搜索到生成的pb文件。</p>
<p>proto文件如下</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line"><span class="keyword">service </span><span class="title class_">Greeter</span> &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHello (HelloRequest) <span class="keyword">returns</span> (HelloReply) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloStreamReply (HelloRequest) <span class="keyword">returns</span> (stream HelloReply) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloBidiStream (stream HelloRequest) <span class="keyword">returns</span> (stream HelloReply) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user&#x27;s name.</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloReply</span> &#123;</span><br><span class="line">  <span class="type">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>client和server代码比较简单就不贴了,只梳理一下流程</p>
<p>我们在proto中定义了Greeter这个service，protoc会自动帮我们生成pb文件实现这个类，客户端指名server端地址以后，只需要实例化一个channel传递给客户端的构造函数，然后进一步实例化Greeter::Stub这个类，客户端发送请求的时候，内部其实就是通过这个stub去发送的。</p>
<p>服务端需要重写SayHello方法，然后注册service以后，server.wait一直等。</p>
<h4 id="grpc的一些坑">grpc的一些坑</h4>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export MY_INSTALL_DIR=$HOME/.local</span><br><span class="line"></span><br><span class="line">mkdir -p $MY_INSTALL_DIR</span><br><span class="line"></span><br><span class="line">export PATH=&quot;$MY_INSTALL_DIR/bin:$PATH&quot;</span><br><span class="line"></span><br><span class="line">sudo apt install -y build-essential autoconf libtool pkg-config</span><br><span class="line"></span><br><span class="line">git clone --recurse-submodules -b v1.72.0 --depth 1 --shallow-submodules https://github.com/grpc/grpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir -p cmake/build</span><br><span class="line">pushd cmake/build</span><br><span class="line">cmake -DgRPC_INSTALL=ON \</span><br><span class="line">      -DgRPC_BUILD_TESTS=OFF \</span><br><span class="line">      -DCMAKE_CXX_STANDARD=17 \</span><br><span class="line">      -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \</span><br><span class="line">      ../..</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mkdir -p cmake/build</span><br><span class="line">pushd cmake/build</span><br><span class="line">cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -DCMAKE_CXX_STANDARD=17../..</span><br><span class="line">make -j4</span><br><span class="line"></span><br><span class="line">protoc --cpp_out=. contact.proto </span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>absl::check</code>之类的经常出现先链接库的时候，但他们其实不是库，他们只是一个编译target，在某些cmake文件里面会定义，不用深究。。</p>
</li>
<li>
<p>vscode报红，设置里面选C_Cpp.SelectIntelliSenseConfiguration，选一个配置就行，一般选cmake生成的compile_commands.json就行。</p>
</li>
</ul>
<h3 id="rocket的调用流程">rocket的调用流程</h3>
<p><code>class RpcController : public google::protobuf::RpcController</code>：貌似是来记录一次调用的相关信息</p>
<p><code>class RpcClosure : public google::protobuf::Closure</code></p>
<p><code>class RpcInterface : public std::enable_shared_from_this&lt;RpcInterface&gt;</code></p>
<p><code>class RpcChannel : public google::protobuf::RpcChannel, public std::enable_shared_from_this&lt;RpcChannel&gt;</code></p>
<h4 id="客户端流程">客户端流程</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  rocket::Config::<span class="built_in">SetGlobalConfig</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  rocket::Logger::<span class="built_in">InitGlobalLogger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// test_tcp_client();</span></span><br><span class="line">  <span class="built_in">test_rpc_channel</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">INFOLOG</span>(<span class="string">&quot;test_rpc_channel end&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_rpc_channel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NEWRPCCHANNEL</span>(<span class="string">&quot;127.0.0.1:12345&quot;</span>, channel);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::shared_ptr&lt;makeOrderRequest&gt; request = std::make_shared&lt;makeOrderRequest&gt;();</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NEWMESSAGE</span>(makeOrderRequest, request);</span><br><span class="line">  <span class="built_in">NEWMESSAGE</span>(makeOrderResponse, response);</span><br><span class="line"></span><br><span class="line">  request-&gt;<span class="built_in">set_price</span>(<span class="number">100</span>);</span><br><span class="line">  request-&gt;<span class="built_in">set_goods</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">NEWRPCCONTROLLER</span>(controller);</span><br><span class="line">  controller-&gt;<span class="built_in">SetMsgId</span>(<span class="string">&quot;99998888&quot;</span>);</span><br><span class="line">  controller-&gt;<span class="built_in">SetTimeout</span>(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;rocket::RpcClosure&gt; closure = std::<span class="built_in">make_shared</span>&lt;rocket::RpcClosure&gt;(<span class="literal">nullptr</span>, [request, response, channel, controller]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (controller-&gt;<span class="built_in">GetErrorCode</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">INFOLOG</span>(<span class="string">&quot;call rpc success, request[%s], response[%s]&quot;</span>, request-&gt;<span class="built_in">ShortDebugString</span>().<span class="built_in">c_str</span>(), response-&gt;<span class="built_in">ShortDebugString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">      <span class="comment">// 执行业务逻辑</span></span><br><span class="line">      <span class="keyword">if</span> (response-&gt;<span class="built_in">order_id</span>() == <span class="string">&quot;xxx&quot;</span>) &#123;</span><br><span class="line">        <span class="comment">// xx</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">ERRORLOG</span>(<span class="string">&quot;call rpc failed, request[%s], error code[%d], error info[%s]&quot;</span>, </span><br><span class="line">        request-&gt;<span class="built_in">ShortDebugString</span>().<span class="built_in">c_str</span>(), </span><br><span class="line">        controller-&gt;<span class="built_in">GetErrorCode</span>(), </span><br><span class="line">        controller-&gt;<span class="built_in">GetErrorInfo</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">INFOLOG</span>(<span class="string">&quot;now exit eventloop&quot;</span>);</span><br><span class="line">    <span class="comment">// channel-&gt;getTcpClient()-&gt;stop();</span></span><br><span class="line">    channel.<span class="built_in">reset</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  &#123;</span><br><span class="line">    std::shared_ptr&lt;rocket::RpcChannel&gt; channel = std::<span class="built_in">make_shared</span>&lt;rocket::RpcChannel&gt;(rocket::RpcChannel::<span class="built_in">FindAddr</span>(<span class="string">&quot;127.0.0.1:12345&quot;</span>));</span><br><span class="line">    ;</span><br><span class="line">    channel-&gt;<span class="built_in">Init</span>(controller, request, response, closure);</span><br><span class="line">    <span class="built_in">Order_Stub</span>(channel.<span class="built_in">get</span>()).<span class="built_in">makeOrder</span>(controller.<span class="built_in">get</span>(), request.<span class="built_in">get</span>(), response.<span class="built_in">get</span>(), closure.<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CALLRPRC(&quot;127.0.0.1:12345&quot;, Order_Stub, makeOrder, controller, request, response, closure);</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// xxx</span></span><br><span class="line">  <span class="comment">// 协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化GlobalConfig、初始化Logger模块。以上两步其实是和server端是复用的，主要是server端需要读取xml配置，Logger模块分配两个线程。客户端不用做这些。</p>
<p>依次构建channel、request、response、controller、closure等。channel的构建其实就是拿到服务端的ip port，这些数据是从xml配置中读的，初始化channel就只是保存了服务端的地址端口信息m_peer_addr。然后Init再进行一些赋值等。request是Message对象，会进行一些数据填充。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Order_Stub</span>(channel.<span class="built_in">get</span>()).<span class="built_in">makeOrder</span>(controller.<span class="built_in">get</span>(), request.<span class="built_in">get</span>(), response.<span class="built_in">get</span>(), closure.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<p>这段代码实际上走到了<code>RpcChannel::CallMethod</code></p>
<ul>
<li>
<p>构建一个<code>std::shared_ptr&lt;rocket::TinyPBProtocol&gt; req_protocol</code></p>
</li>
<li>
<p>一些校验</p>
</li>
<li>
<p>构建一个<code>m_client = std::make_shared&lt;TcpClient&gt;(m_peer_addr);</code></p>
</li>
<li>
<p><code>req_protocol设置m_msg_id、m_method_name</code></p>
</li>
<li>
<p><code>request-&gt;SerializeToString(&amp;(req_protocol-&gt;m_pb_data))</code>,序列化request，结果保存在m_pb_data中，这里虽然用string存，但是内部其实都是二进制数据。</p>
</li>
<li>
<p>设置一个单次定时事件，超时未完成就手动销毁，把该定时事件加到m_client 中</p>
</li>
<li>
<p>m_client-&gt;connect，这里会传入一个回调done，connect逻辑比较简单，就是原生的connect，返回0表示连接成功，然后执行done回调，返回-1的话就看看是不是在连接中EINPROGRESS，是就把这个fdevent监听可写，可写触发connect、初始化本地addr、设置连接状态等，也就是正常connect的情况。最后把这个fdevent删掉。因为这里只是为了保证下次连接正常进行，否则会一直触发写。</p>
</li>
<li>
<p>connect里面的回调，正常来说是连接成功了才会执行。匿名函数内部首先校验有没有错误，然后执行getTcpClient()-&gt;writeMessage()，其中匿名函数捕获了req_protocol和this，其实就是连接成功以后记录了一对&lt;message,done&gt;，然后监听可写事件,这里可写的回调就是把前面记录的message编码以后通过socket发送出去（message就是req_protocol，req_protocol中存着request序列化以后的数据），发送完了以后，然后依次执行前面的done回调函数，在这个回调函数中，会调用getTcpClient()-&gt;readMessage()，其中第一个参数req_protocol-&gt;m_msg_id，第二个参数是匿名函数，捕获了this和my_controller。这里其实是上面的回调触发的时候执行到这里，然后又记录一对&lt;msg_id,done&gt;，然后监听可读事件，代表服务端已经执行完了送来了response。在这个done里面就是判断response有没有解析出错，没问题的话就执行callback回调，callback回调就比较简单了，标记finished，然后执行m_closure-&gt;run。这里的response怎么来的呢？其实是readMessage监听可读事件的时候，检测到可读了，然后触发可读的回调，TcpConnection::onRead，在这个函数里面首先从socket中读出数据存在in_buffer中，然后调用excute函数，依次解码得到message对象，然后执行之前记录好的回调。<font color=red>总结来说，就是connect的时候，注册一个回调A，连接上了才会执行回调A。在A里面又调用了writeMessage，在这个函数中会注册回调B，writeMessage这个函数其实就是把req_protocol写入到m_out_buffer，然后全部发送出去，在内部会记录每个req_protocol和其对应的回调。发送完了以后执行回调B。而在回调B中，又会调用readMessage，在这个函数中，又会注册回调C。readMessage是用来读取数据到m_in_buffer，在内部会记录每次请求的m_msg_id以及对应的回调，然后在excute里面，根据是服务端还是客户端，分别执行请求的分发和客户端自己的回调。在回调C中，其实就是收到服务端的响应以后，进行反序列化拿到response，也就是message，然后进行校验，最后调用RpcChannel::callBack标记这一次请求已经完成，然后执行closure里面的run函数，内部就是执行初始化closure时传入的回调函数。closure一般来说是一次rpc请求完成以后，在客户端执行的，在这里可以执行真正的业务逻辑。</font></p>
</li>
<li>
<p>TcpConnection::onWrite 该函数客户端和服务端其实共用了，如果是客户端就会先encode到m_out_buffer，然后再发送，发送完了，如果是客户端，再额外执行事先绑定的回调，也就是写回调，写回调里面会调用getTcpClient()-&gt;readMessage()，会注册一个读回调</p>
</li>
<li>
<p>TcpConnection::onRead 该函数客户端和服务端也是共用了。从socket中读取数据存在in_buffer中，然后执行excute函数，如果是客户端，就decode得到message对象，然后执行之前注册的回调。如果是服务端，就代表要处理多少个响应</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (m_connection_type == TcpConnectionByServer) &#123;</span><br><span class="line">  <span class="comment">// 将 RPC 请求执行业务逻辑，获取 RPC 响应, 再把 RPC 响应发送回去</span></span><br><span class="line">  std::vector&lt;AbstractProtocol::s_ptr&gt; result;</span><br><span class="line">  m_coder-&gt;<span class="built_in">decode</span>(result, m_in_buffer);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>;  i &lt; result.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 1. 针对每一个请求，调用 rpc 方法，获取响应 message</span></span><br><span class="line">    <span class="comment">// 2. 将响应 message 放入到发送缓冲区，监听可写事件回包</span></span><br><span class="line">    <span class="built_in">INFOLOG</span>(<span class="string">&quot;success get request[%s] from client[%s]&quot;</span>, result[i]-&gt;m_msg_id.<span class="built_in">c_str</span>(), m_peer_addr-&gt;<span class="built_in">toString</span>().<span class="built_in">c_str</span>());</span><br><span class="line">  </span><br><span class="line">    std::shared_ptr&lt;TinyPBProtocol&gt; message = std::<span class="built_in">make_shared</span>&lt;TinyPBProtocol&gt;();</span><br><span class="line">    <span class="comment">// message-&gt;m_pb_data = &quot;hello. this is rocket rpc test data&quot;;</span></span><br><span class="line">    <span class="comment">// message-&gt;m_msg_id = result[i]-&gt;m_msg_id;</span></span><br><span class="line">  </span><br><span class="line">    RpcDispatcher::<span class="built_in">GetRpcDispatcher</span>()-&gt;<span class="built_in">dispatch</span>(result[i], message, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>RpcDispatcher::dispatch 该函数就是用来分发服务调用的，首先进行一些校验，构造rsp_protocol，获取method、service，构造两个google::protobuf::Message，req_msg和rsp_msg，然后将req_protocol-&gt;m_pb_data的数据反序列化保存在req_msg中，然后构建一个RpcController* rpc_controller，最后构建一个RpcClosure，构造函数里面会注册一个<strong>回调</strong>(在这个回调里首先将rsp_msg序列化到rsp_protocol-&gt;m_pb_data中，然后调用TcpConnection的reply函数，在内部encode rsp_protocol，然后监听可写，写入发到对端)最后调用service-&gt;CallMethod，这里是服务端调用method的地方。最终调到了OrderImpl::makeOrder，这是协议里面定义的rpc服务具体的实现，内部就是把request校验一下，然后给response填充，完了以后调用前面done-&gt;run,也就是前面RpcClosure事先注册的<strong>回调</strong>。</p>
</li>
</ul>
<h4 id="服务端流程">服务端流程</h4>
<p>编写OrderImpl继承自Order类，在这里实现真正的服务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start test_rpc_server error, argc not 2 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start like this: \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;./test_rpc_server ../conf/rocket.xml \n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  rocket::Config::<span class="built_in">SetGlobalConfig</span>(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  rocket::Logger::<span class="built_in">InitGlobalLogger</span>();</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;OrderImpl&gt; service = std::<span class="built_in">make_shared</span>&lt;OrderImpl&gt;();</span><br><span class="line">  rocket::RpcDispatcher::<span class="built_in">GetRpcDispatcher</span>()-&gt;<span class="built_in">registerService</span>(service);</span><br><span class="line"></span><br><span class="line">  rocket::IPNetAddr::s_ptr addr = std::<span class="built_in">make_shared</span>&lt;rocket::IPNetAddr&gt;(<span class="string">&quot;127.0.0.1&quot;</span>, rocket::Config::<span class="built_in">GetGlobalConfig</span>()-&gt;m_port);</span><br><span class="line"></span><br><span class="line">  <span class="function">rocket::TcpServer <span class="title">tcp_server</span><span class="params">(addr)</span></span>;</span><br><span class="line"></span><br><span class="line">  tcp_server.<span class="built_in">start</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>std::shared_ptr<code>&lt;OrderImpl&gt;</code> service，然后注册服务，在内部其实是有一个map，key为服务名，value为具体的服务实例。然后构建一个TcpServer，然后start开启循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  m_acceptor = std::<span class="built_in">make_shared</span>&lt;TcpAcceptor&gt;(m_local_addr);</span><br><span class="line"></span><br><span class="line">  m_main_event_loop = EventLoop::<span class="built_in">GetCurrentEventLoop</span>();</span><br><span class="line">  m_io_thread_group = <span class="keyword">new</span> <span class="built_in">IOThreadGroup</span>(Config::<span class="built_in">GetGlobalConfig</span>()-&gt;m_io_threads);</span><br><span class="line"></span><br><span class="line">  m_listen_fd_event = <span class="keyword">new</span> <span class="built_in">FdEvent</span>(m_acceptor-&gt;<span class="built_in">getListenFd</span>());</span><br><span class="line">  m_listen_fd_event-&gt;<span class="built_in">listen</span>(FdEvent::IN_EVENT, std::<span class="built_in">bind</span>(&amp;TcpServer::onAccept, <span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">  m_main_event_loop-&gt;<span class="built_in">addEpollEvent</span>(m_listen_fd_event);</span><br><span class="line"></span><br><span class="line">  m_clear_client_timer_event = std::<span class="built_in">make_shared</span>&lt;TimerEvent&gt;(<span class="number">5000</span>, <span class="literal">true</span>, std::<span class="built_in">bind</span>(&amp;TcpServer::ClearClientTimerFunc, <span class="keyword">this</span>));</span><br><span class="line">	m_main_event_loop-&gt;<span class="built_in">addTimerEvent</span>(m_clear_client_timer_event);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构建TcpServer的时候，在init中会构建一个TcpAcceptor，这个就是拿来listen和accept的，成功会记录一对&lt;cliendfd,peer_addr&gt;。然后就是自己会维护一个主eventloop，然后创建4个IO线程，即4个从eventloop。然后创建一个事件，检测可读，回调为TcpServer::onAccept。加入到主eventloop中，然后加一个每5s定时任务到主eventloop中。然后开启主从loop的循环。</p>
<p>TcpServer::onAccept()中就是用m_acceptor-&gt;accept拿到连接的fd，然后取出来一个IO线程对象，然后构建一个TcpConnection对象，每个对象都有一个eventloop，<strong>但是这个eventloop是IO线程的</strong>，如果是服务端，就还需要监听可读。然后可读的回调TcpConnection::onRead其实就是从socket读数据，然后解码成rpc请求分发到真正的服务那里执行。这里可能还有一个疑惑。fdevent没有绑定fd啊？实际上在初始化的时候，m_fd_event = FdEventGroup::GetFdEventGroup()-&gt;getFdEvent(fd);这里就事先建立了fd和m_fd_event的映射关系，其实就是事先创建好了128个fdevent，对应的fd就是0-127。</p>
<p><font color=red>总结来说，服务端在TcpServer::init里面注册了新连接的回调，TcpServer::onAccept。在这个函数里面，每连接一个新客户端的时候，都会从4个IO线程中，选出来一个交给他去管理。并且给每个连接创建一个TcpConnection并且记录，然后监听可读事件。实际上在初始化TcpConnection的时候，因为是在主线程操作的，所以在监听可读事件的时候，会调用m_event_loop-&gt;addEpollEvent(m_fd_event);但是这里很明显是在主线程中，调了子线程的eventloop，所以构造一个task存起来，存在子线程对应的eventloop的m_pending_tasks中，然后唤醒这个子线程的eventloop，唤醒是为了防止这个子eventloop是在阻塞。</font></p>
<p>再回过头来看eventloop::loop到底是什么死循环呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m_is_looping = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span>(!m_stop_flag) &#123;</span><br><span class="line">    <span class="function">ScopeMutex&lt;Mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>; </span><br><span class="line">    std::queue&lt;std::function&lt;<span class="type">void</span>()&gt;&gt; tmp_tasks; </span><br><span class="line">    m_pending_tasks.<span class="built_in">swap</span>(tmp_tasks); </span><br><span class="line">    lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!tmp_tasks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::function&lt;<span class="type">void</span>()&gt; cb = tmp_tasks.<span class="built_in">front</span>();</span><br><span class="line">      tmp_tasks.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        <span class="built_in">cb</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有定时任务需要执行，那么执行</span></span><br><span class="line">    <span class="comment">// 1. 怎么判断一个定时任务需要执行？ （now() &gt; TimerEvent.arrtive_time）</span></span><br><span class="line">    <span class="comment">// 2. arrtive_time 如何让 eventloop 监听</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最多等待10000ms</span></span><br><span class="line">    <span class="type">int</span> timeout = g_epoll_max_timeout; </span><br><span class="line">    epoll_event result_events[g_epoll_max_events];</span><br><span class="line">    <span class="comment">// DEBUGLOG(&quot;now begin to epoll_wait&quot;);</span></span><br><span class="line">    <span class="type">int</span> rt = <span class="built_in">epoll_wait</span>(m_epoll_fd, result_events, g_epoll_max_events, timeout);</span><br><span class="line">    <span class="comment">// DEBUGLOG(&quot;now end epoll_wait, rt = %d&quot;, rt);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">ERRORLOG</span>(<span class="string">&quot;epoll_wait error, errno=%d, error=%s&quot;</span>, errno, <span class="built_in">strerror</span>(errno));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rt; ++i) &#123;</span><br><span class="line">        epoll_event trigger_event = result_events[i];</span><br><span class="line">        FdEvent* fd_event = <span class="built_in">static_cast</span>&lt;FdEvent*&gt;(trigger_event.data.ptr);</span><br><span class="line">        <span class="keyword">if</span> (fd_event == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="built_in">ERRORLOG</span>(<span class="string">&quot;fd_event = NULL, continue&quot;</span>);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int event = (int)(trigger_event.events); </span></span><br><span class="line">        <span class="comment">// DEBUGLOG(&quot;unkonow event = %d&quot;, event);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (trigger_event.events &amp; EPOLLIN) &#123; </span><br><span class="line"></span><br><span class="line">          <span class="comment">// DEBUGLOG(&quot;fd %d trigger EPOLLIN event&quot;, fd_event-&gt;getFd())</span></span><br><span class="line">          <span class="built_in">addTask</span>(fd_event-&gt;<span class="built_in">handler</span>(FdEvent::IN_EVENT));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (trigger_event.events &amp; EPOLLOUT) &#123; </span><br><span class="line">          <span class="comment">// DEBUGLOG(&quot;fd %d trigger EPOLLOUT event&quot;, fd_event-&gt;getFd())</span></span><br><span class="line">          <span class="built_in">addTask</span>(fd_event-&gt;<span class="built_in">handler</span>(FdEvent::OUT_EVENT));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// EPOLLHUP EPOLLERR</span></span><br><span class="line">        <span class="keyword">if</span> (trigger_event.events &amp; EPOLLERR) &#123;</span><br><span class="line">          <span class="built_in">DEBUGLOG</span>(<span class="string">&quot;fd %d trigger EPOLLERROR event&quot;</span>, fd_event-&gt;<span class="built_in">getFd</span>())</span><br><span class="line">          <span class="comment">// 删除出错的套接字</span></span><br><span class="line">          <span class="built_in">deleteEpollEvent</span>(fd_event);</span><br><span class="line">          <span class="keyword">if</span> (fd_event-&gt;<span class="built_in">handler</span>(FdEvent::ERROR_EVENT) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">DEBUGLOG</span>(<span class="string">&quot;fd %d add error callback&quot;</span>, fd_event-&gt;<span class="built_in">getFd</span>())</span><br><span class="line">            <span class="built_in">addTask</span>(fd_event-&gt;<span class="built_in">handler</span>(FdEvent::OUT_EVENT));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>swap一次性取出任务</li>
<li>依次执行任务（比如对应上面的task，也就是addevent）</li>
<li>然后就是执行epoll_wait，有一个超时时间。如果有返回值，那么就代表有可读或者可写事件，然后分别将相对应的回调addTask</li>
</ul>
<h3 id="值得注意的点">值得注意的点</h3>
<ul>
<li>
<p>AsyncLogger::Loop在while循环的时候，进去就直接上锁，子while循环直接阻塞，等到新buffer来了，才会解除阻塞，然后继续拿回锁</p>
</li>
<li>
<p>主线程会保留所有io线程的编号和线程对象，也就间接保留了所有从eventloop的对象。因为每个从eventloop初始化时会记录当前子线程的id。所以主线程的accept回调触发的时候，最终是在主线程里面拿到某个子线程的eventloop，然后addEpollEvent。具体调用为TcpServer::onAccept–&gt;实例化TcpConnection::s_ptr connetion–&gt;TcpConnection::listenRead–&gt;m_event_loop-&gt;addEpollEvent</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* event_loop, <span class="type">int</span> fd, <span class="type">int</span> buffer_size, NetAddr::s_ptr peer_addr, NetAddr::s_ptr local_addr, TcpConnectionType type <span class="comment">/*= TcpConnectionByServer*/</span>)</span><br><span class="line">    : <span class="built_in">m_event_loop</span>(event_loop), <span class="built_in">m_local_addr</span>(local_addr), <span class="built_in">m_peer_addr</span>(peer_addr), <span class="built_in">m_state</span>(NotConnected), <span class="built_in">m_fd</span>(fd), <span class="built_in">m_connection_type</span>(type) &#123;</span><br><span class="line">    </span><br><span class="line">  m_in_buffer = std::<span class="built_in">make_shared</span>&lt;TcpBuffer&gt;(buffer_size);</span><br><span class="line">  m_out_buffer = std::<span class="built_in">make_shared</span>&lt;TcpBuffer&gt;(buffer_size);</span><br><span class="line"></span><br><span class="line">  m_fd_event = FdEventGroup::<span class="built_in">GetFdEventGroup</span>()-&gt;<span class="built_in">getFdEvent</span>(fd);</span><br><span class="line">  m_fd_event-&gt;<span class="built_in">setNonBlock</span>();</span><br><span class="line"></span><br><span class="line">  m_coder = <span class="keyword">new</span> <span class="built_in">TinyPBCoder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (m_connection_type == TcpConnectionByServer) &#123;</span><br><span class="line">    <span class="built_in">listenRead</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::listenRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  m_fd_event-&gt;<span class="built_in">listen</span>(FdEvent::IN_EVENT, std::<span class="built_in">bind</span>(&amp;TcpConnection::onRead, <span class="keyword">this</span>));</span><br><span class="line">  m_event_loop-&gt;<span class="built_in">addEpollEvent</span>(m_fd_event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EventLoop::isInLoopThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getThreadId</span>() == m_thread_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是当前线程调用自己的eventloop，那么直接添加到 epoll 里面</span></span><br><span class="line"><span class="comment">// 如果不是当前线程调用自己的eventloop，那么添加到任务队列里面，等到自己线程执行完后再添加到 epoll 里面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::addEpollEvent</span><span class="params">(FdEvent* event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">isInLoopThread</span>()) &#123;</span><br><span class="line">    <span class="built_in">ADD_TO_EPOLL</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> cb = [<span class="keyword">this</span>, event]() &#123;</span><br><span class="line">      <span class="built_in">ADD_TO_EPOLL</span>();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">addTask</span>(cb, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>所以现在当前线程的id，和eventloop绑定的id，不是同一个，那么就走到了EventLoop::addTask。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::addTask</span><span class="params">(std::function&lt;<span class="type">void</span>()&gt; cb, <span class="type">bool</span> is_wake_up <span class="comment">/*=false*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">ScopeMutex&lt;Mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">  m_pending_tasks.<span class="built_in">push</span>(cb);</span><br><span class="line">  lock.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_wake_up) &#123;</span><br><span class="line">    <span class="built_in">wakeup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>那为什么要加锁</strong>？首先这里的锁，是每个eventloop独有的。各个子线程之间貌似互不干扰啊？但是从上面的分析可以看到，这里是主线程调到了子线程的eventloop（因为事先记录了！）所以这里的eventloop实际上就是一个临界资源（共享数据）呀！刚好这个临界资源（共享数据）又有一把锁，这不就类似于主线程子线程共用一个全局变量锁吗！所以在每个eventloop里面操作的时候，都需要加锁上锁呀！</p>
<p>那再看看addTask到底做了啥呢？就是把任务放到这个eventloop的队列里，然后再调用wakeup！那wakeup到底做了啥？在每个eventloop初始化的时候，都会调用initWakeUpFdEevent，在这里会创建一个eventfd。然后一直监听！wakeup本质上就是触发一次可读事件，然后解除epoll的阻塞。这里wakeup的意义就是怕这个从eventloop一直阻塞住了，我现在要让他去监听新的客户端fd，所以通过这个eventfd去解除他的阻塞！值得注意的是，如果这个eventloop之前就监听了一些客户端fd，刚好这个时候有客户端fd可读了，也解除了epoll的阻塞，那么确实当前这个wakeup就没啥意义了！总之，我们手动wakeup一次，触发可读，保证解除epoll阻塞，肯定是有意义的，不管怎样，都能保证eventloop及时处理新来的任务！这里新来的任务就是监听新的客户端fd，其实也可以是其他任务，比如注销fd，某些定时任务，回调函数等等！但是在这份源码中好像是只有连接回调，也就是监听新的客户端fd。</p>
</li>
<li>
<p>在eventloop开头的时候，直接swap，可以高效取出所有的任务，减少上锁的时间，相当于利用c++的特性吧，然后后面再慢慢处理每个task</p>
</li>
<li>
<p><font color=red>每个m_fd_event-&gt;listen的时候，都会在内部保存m_listen_events.data.ptr = this;这样每次epoll返回的时候，能够拿到这个FdEvent对象。</font></p>
</li>
<li>
<p>任务的最终执行其实都是在eventloop的开头，epoll返回的时候，会告诉你哪个fd可写可读，该fd会与一个FdEvent绑定，我们需要转换成FdEvent，然后根据fd是可读还是可写，找到事先定义好的回调，然后添加到任务列表<strong>m_pending_tasks</strong>中</p>
</li>
<li>
<p>req_msg和rsp_msg都是google::protobuf::Message*类型，proto文件中定义的rpc服务，request和response实际上都是继承自Message</p>
</li>
<li>
<p>service是google::protobuf::Service类型</p>
</li>
<li>
<p><font color=red>socket通信的时候，客户端连接触发可写，服务端连接触发可读。</font></p>
</li>
<li>
<p>客户端请求的时候，request对象赋值以后，先是声明req_protocol，然后序列化到req_protocol-&gt;m_pb_data中，然后再将这个req_protocol编码，也就是encode，<strong>其实就是把req_protocol转化成字节流数组</strong>，然后写入到m_out_buffer中，最后通过write发过去。服务端读取的时候，数据读到m_in_buffer中，然后再decode还原成TinyPBProtocol，也就是客户端发过来的req_protocol对象。然后反序列化req_protocol-&gt;m_pb_data到<strong>req_msg</strong>中，其实就是request对象。然后服务端处理完以后，构建一个response对象。然后在服务端的closure中，再把这个reponse序列化为<strong>rsp_protocol</strong>，最后调用connection-&gt;reply(replay_messages);内部同样是encode编码以后发出去。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"># c++</a>
              <a href="/tags/rpc/" rel="tag"># rpc</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/04/27/%E6%B5%85%E8%B0%88Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="prev" title="浅谈Python多线程和多进程">
      <i class="fa fa-chevron-left"></i> 浅谈Python多线程和多进程
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC"><span class="nav-text">RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%92%8Cgrpc%E6%9C%8D%E5%8A%A1%EF%BC%9F"><span class="nav-text">通用服务和grpc服务？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="nav-text">关于一些版本问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grpc%E5%AE%98%E6%96%B9%E4%BE%8B%E5%AD%90"><span class="nav-text">grpc官方例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grpc%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91"><span class="nav-text">grpc的一些坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rocket%E7%9A%84%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-text">rocket的调用流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="nav-text">客户端流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B5%81%E7%A8%8B"><span class="nav-text">服务端流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="nav-text">值得注意的点</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhangyitao</p>
  <div class="site-description" itemprop="description">一切过往，皆为序曲</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyitao</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
